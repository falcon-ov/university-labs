# Отчет по лабораторной работе: Простое развертывание инфраструктуры на Google Cloud Platform с Terraform

## Цель работы
Научиться создавать базовую инфраструктуру на облачной платформе с помощью Terraform, включая виртуальную машину и облачное хранилище, используя переменные и выходные данные, а также безопасно хранить состояние инфраструктуры.

## Используемые инструменты
- **Платформа:** Google Cloud Platform (GCP)
- **Инструмент IaC:** Terraform (версия >= 1.0)
- **Среда разработки:** Google Cloud Shell

**Примечание:** Лабораторная работа была выполнена в Google Cloud Platform вместо AWS, так как у меня была возможность воспользоваться бесплатными ресурсами GCP.

## Ход выполнения работы

### 1. Подготовка окружения

Я установил Terraform в Google Cloud Shell и настроил учетные данные для работы с GCP. Terraform был доступен через встроенные инструменты Cloud Shell, что упростило начальную настройку.

### 2. Создание структуры проекта

Я создал директорию `aws_simple_lab` для проекта и внутри неё подготовил три основных файла конфигурации Terraform:

- **`main.tf`** — для описания провайдера GCP и основных ресурсов
- **`variables.tf`** — для определения входных переменных
- **`outputs.tf`** — для вывода результатов развертывания

В файле `main.tf` я настроил провайдер Google Cloud, указав регион через переменную `gcp_region` (адаптировал от изначальной `aws_region`).

### 3. Создание файла переменных

В `terraform.tfvars` я задал следующие значения:

```
project_id = "dark-throne-479409-d1"
env        = "dev"
```

Где `project_id` — это мой идентификатор проекта в GCP, а `env` определяет окружение для развертывания.

### 4. Развертывание виртуальной машины

В `main.tf` я добавил ресурс для создания виртуальной машины (аналог EC2-инстанса в AWS). Использовал образ машины для GCP и тип инстанса, эквивалентный `t2.micro`. Добавил метки (labels) для инстанса, включающие переменную `env`, например, `webserver-dev`.

### 5. Создание облачного хранилища

Я добавил ресурс для создания Cloud Storage бакета (аналог S3-бакета). Имя бакета настроил как уникальное с использованием переменной `env`. Настроил бакет с приватным доступом для обеспечения безопасности данных.

### 6. Настройка выходных данных

В файле `outputs.tf` я определил два выходных параметра:
- Публичный IP-адрес виртуальной машины
- Имя созданного Storage бакета

### 7. Настройка удаленного состояния

Я создал отдельный Cloud Storage бакет для хранения файла состояния `terraform.tfstate`. В `main.tf` настроил backend для хранения состояния с использованием шифрования. Убедился, что state-файл не добавляется в систему контроля версий.

### 8. Инициализация и применение конфигурации

#### Инициализация Terraform

Я выполнил команду `terraform init` для инициализации провайдера и backend:

![Инициализация Terraform](/images/img_1.png)

Terraform успешно загрузил необходимые провайдеры и настроил удаленное хранилище состояния.

#### Просмотр плана изменений

Затем я выполнил `terraform plan` для просмотра плана создаваемых ресурсов:

![План изменений](/images/img_2.png)

Terraform показал, какие ресурсы будут созданы: виртуальная машина и Cloud Storage бакет.

#### Применение конфигурации

Я применил конфигурацию командой `terraform apply`:

![Применение конфигурации](/images/img_3.png)

Terraform успешно создал все запланированные ресурсы в GCP.

### 9. Проверка результатов

#### Вывод результатов

Я проверил выходные данные командой `terraform output`:

![Выходные данные](/images/img_4.png)

Команда отобразила публичный IP-адрес виртуальной машины и имя созданного Storage бакета.

#### Проверка состояния в Cloud Storage

Я убедился, что файл состояния `terraform.tfstate` сохранен в Cloud Storage бакете:

![State-файл в Storage (1)](/images/img_5.png)
![State-файл в Storage (2)](/images/img_6.png)
![State-файл в Storage (3)](/images/img_7.png)

Файл состояния был успешно сохранен в удаленном хранилище с включенным шифрованием.

### 10. Очистка ресурсов

#### Удаление инфраструктуры

Для очистки созданных ресурсов я выполнил команду `terraform destroy`:

![Удаление ресурсов (1)](/images/img_8.png)
![Удаление ресурсов (2)](/images/img_9.png)
![Удаление ресурсов (3)](/images/img_10.png)

Terraform запросил подтверждение и удалил все созданные ресурсы.

#### Проверка удаления

Я проверил в консоли GCP, что виртуальная машина и Cloud Storage бакет были успешно удалены:

![Проверка удаления](/images/img_11.png)

Все ресурсы были корректно удалены из облачной инфраструктуры.

## Выводы

В ходе выполнения лабораторной работы я:

1. **Освоил основы работы с Terraform** в облачной среде Google Cloud Platform
2. **Создал базовую инфраструктуру**, включающую виртуальную машину и облачное хранилище
3. **Настроил использование переменных** для параметризации конфигурации и переиспользования кода
4. **Реализовал выходные данные** для получения информации о созданных ресурсах
5. **Настроил удаленное хранилище состояния** с шифрованием для безопасной работы в команде
6. **Успешно применил полный цикл управления инфраструктурой**: инициализация → планирование → создание → проверка → удаление

Работа с Terraform показала эффективность подхода Infrastructure as Code для управления облачными ресурсами. Декларативный подход и возможность версионирования инфраструктуры делают процесс развертывания прозрачным и воспроизводимым.

Адаптация лабораторной работы под Google Cloud Platform вместо AWS не вызвала существенных трудностей благодаря схожести концепций облачных сервисов и универсальности Terraform как инструмента.