# Inteligență artificială: Лабораторная работа №1 
### **Вариант 19**

**Выполнил студент:\
Группы I2302\
Daniil Socolov**

**Проверил преподаватель:\
V.Trebis**

## Задание

Написать программу реализующую ĸонечный автомат, ĸоторый распознает слова, имеющие следующий общий вид.

**Вариант 19.** `a^n(bc)^m*(de)^k, n >=1, m>=1,k>=1, m - нечетное`

## Выполнение
Написать программу на Java, реализующую конечный автомат, который принимает и распознает строки над алфавитом {a, b, c, d, e} следующего вида:
- сначала ровно n символов a (n ≥ 1),
- затем m подряд идущих пар bc (т.е. блок (bc) повторяется m раз), причём m ≥ 1 и m- нечётное,
- затем k подряд идущих пар de (т.е. блок (de) повторяется k раз), k ≥ 1,
- никаких дополнительных символов до начала или после конца строки быть не должно.
## Описание алгоритма

Конечный автомат реализован с помощью состояний:
- S0 - начальное состояние
- S1 - обработка символов 'a' (n ≥ 1)
- S2 - ожидание 'b' для первой пары "bc"
- S3 - ожидание 'c' после 'b'
- S4 - четное количество пар "bc" (ожидание 'b' или 'd')
- S5 - ожидание 'c' после 'b' (для четных пар)
- S6 - ожидание 'd' для пар "de"
- S7 - ожидание 'e' после 'd'
- S8 - конечное состояние (принимающее)
- ERROR - состояние ошибки

## Описание кода

Программа реализует конечный автомат для распознавания строк языка  
`a^n(bc)^m(de)^k`, где `n ≥ 1`, `m ≥ 1` (m — нечётное), `k ≥ 1`.


### 1. Определение состояний автомата
В начале программы создаётся перечисление `State`, где задаются все состояния конечного автомата, включая ошибочное:

```java
enum State {
    S0,     // Начальное состояние
    S1,     // Обработка символов 'a'
    S2,     // Ожидание 'c' после 'b'
    S3,     // Нечетное количество пар "bc"
    S4,     // Четное количество пар "bc"
    S6,     // Ожидание 'e' после 'd'
    S7,     // После корректной пары "de"
    S8,     // Конечное принимающее состояние
    ERROR   // Ошибка
}
```

### 2. Поля и инициализация
В классе хранится текущее состояние и счётчик пар `bc`.  
Метод `reset()` сбрасывает автомат в начальное состояние:

```java
private State currentState;
private int bcPairCount;  // Счётчик пар "bc"

public void reset() {
    currentState = State.S0;
    bcPairCount = 0;
}
```

### 3. Обработка символов
Метод `processChar(char c)` реализует переходы между состояниями.  
Например, начальное состояние `S0` принимает только `'a'`, иначе происходит ошибка:

```java
case S0:
    if (c == 'a') {
        currentState = State.S1;
    } else {
        currentState = State.ERROR;
    }
    break;
```

В состоянии `S2` ожидается `'c'`, и после этого увеличивается счётчик пар `bc`:

```java
case S2:
    if (c == 'c') {
        bcPairCount++;
        if (bcPairCount % 2 == 1) {
            currentState = State.S3;  // Нечетное количество пар
        } else {
            currentState = State.S4;  // Четное количество пар
        }
    } else {
        currentState = State.ERROR;
    }
    break;
```

После части `(bc)^m` автомат должен перейти к части `(de)^k`.  
В состоянии `S6` обрабатывается `'e'`:

```java
case S6:
    if (c == 'e') {
        currentState = State.S7;
    } else {
        currentState = State.ERROR;
    }
    break;
```

### 4. Проверка строки
Метод `recognize(String input)` запускает обработку всей строки и проверяет условия:
- автомат должен закончить в состоянии `S7` (т.е. последним символом было `'e'`);
- количество пар `bc` должно быть нечётным.

```java
public boolean recognize(String input) {
    reset();

    for (char c : input.toCharArray()) {
        processChar(c);
        if (currentState == State.ERROR) {
            return false;
        }
    }

    return currentState == State.S7 && bcPairCount % 2 == 1;
}
```

### 5. Трассировка
Для отладки реализован метод `trace(String input)`, который выводит пошаговые переходы состояний:

```java
public void trace(String input) {
    reset();
    System.out.println("\nТрассировка для строки: \"" + input + "\"");
    System.out.println("Начальное состояние: " + currentState);

    for (int i = 0; i < input.length(); i++) {
        char c = input.charAt(i);
        State prevState = currentState;
        processChar(c);
        System.out.println("Символ '" + c + "': " + prevState + " -> " + currentState);
    }

    System.out.println("Количество пар 'bc': " + bcPairCount);
    System.out.println("Результат: " + (recognize(input) ? "ПРИНЯТО" : "ОТВЕРГНУТО"));
}
```

### 6. Тестирование и интерактивный режим
В методе `main` реализованы:
- проверка набора тестовых строк;
- интерактивный режим для ввода пользователем:
  - `exit` — выход из программы;
  - `trace <строка>` — трассировка строки.

Пример тестов:

```java
String[] testStrings = {
    "abcde",           // n=1, m=1, k=1 → ПРИНЯТО
    "aabcde",          // n=2, m=1, k=1 → ПРИНЯТО
    "abcbcbcde",       // n=1, m=3, k=1 → ПРИНЯТО
    "abcbcde",         // m=2 (четное)  → ОТВЕРГНУТО
    "abc"              // нет 'de'      → ОТВЕРГНУТО
};
```

![img](/img_1.png)

![img](/img_2.png)

## Выводы
В данной лабораторной работе был успешно реализован конечный автомат для распознавания языка с грамматикой a^n(bc)^m(de)^k, где n≥1, m≥1 (m - нечетное), k≥1.

**Программа корректно:**
- Распознает строки, соответствующие заданной грамматике
- Отвергает строки, не соответствующие условиям
- Проверяет нечетность количества пар "bc"
- Предоставляет возможность трассировки для отладки
- Имеет интерактивный режим для тестирования
- Автомат успешно обрабатывает все тестовые случаи и может быть использован для проверки принадлежности строк заданному языку.





